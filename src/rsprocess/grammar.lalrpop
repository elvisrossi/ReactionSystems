use std::rc::Rc;
use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::rsprocess::structure::{ RSset,
				   RSprocess,
				   RSenvironment,
				   RSsystem,
				   RSlabel,
				   RSreaction };
use crate::rsprocess::structure::rsassert;
use crate::rsprocess::translator::{ Translator, IdType };
use crate::rsprocess::presets::Instructions;
use crate::rsprocess::presets;
use crate::rsprocess::graph;

grammar(translator: &mut Translator);

// -----------------------------------------------------------------------------
//                                  Helpers
// -----------------------------------------------------------------------------

// order
match {
    ".", ",", ";",
    "nill",
    "{", "}",
    "[", "]",
    "(", ")",
    "<", ">",
    "r:", "i:", "p:",
    "-", "^",
    "true", "false",
    "Environment", "Initial Entities", "Context", "Reactions",
    "Weights", "Sets",
    "Print", "Save",
    "Dot", "GraphML", "Serialize",
    "Stats", "Target", "Run", "Loop", "Frequency", "LimitFrequency",
    "FastFrequency", "Digraph", "Bisimilarity",
    "Deserialize",
    "?",
    "Hide",
    "Entities", "MaskEntities", "UncommonEntities", "UncommonMaskEntities",
    "MaskContext", "UncommonContext", "UncommonMaskContext",
    "Products", "MaskProducts", "UncommonProducts", "UncommonMaskProducts",
    "Union", "MaskUnion", "UncommonUnion", "UncommonMaskUnion",
    "Difference", "MaskDifference",
    "UncommonDifference", "UncommonMaskDifference",
    "EntitiesDeleted", "MaskEntitiesDeleted",
	"UncommonEntitiesDeleted", "UncommonMaskEntitiesDeleted",
    "EntitiesAdded", "MaskEntitiesAdded",
	"UncommonEntitiesAdded", "UncommonMaskEntitiesAdded",
    "label", "edge", "if", "then", "else", "let", "=", "return", "for", "in",
    "not", "rand", "empty", "length", "tostr", "source", "target",
    "&&", "||", "^^", "<=", ">=", "==", "!=", "+", "*", "/", "%",
    "::",
    "substr", "min", "max", "commonsubstr",
    "SystemEntities", "SystemContext",
    "AvailableEntities", "AllReactants", "AllInhibitors",
    "relabel",
} else {
    r"[0-9]+" => NUMBER
} else {
    r"([[:alpha:]])([[:word:]])*" => WORD
    // r"(\p{L}|\p{Emoji})(\p{L}|\p{Emoji}|\p{Dash}|\p{N})*" => WORD,
} else {
    r#""[^"]+""# => PATH, // " <- ignore comment, its for the linter in emacs
} else {
    _
}

// matches words (letter followed by numbers, letters or _)
Literal: String = {
    WORD => <>.into(),
};

LiteralProcess: String = {
    Literal => <>,
    "true" => <>.into(),
    "false" => <>.into(),
    "Environment" => <>.into(),
    "Initial" => <>.into(),
    "Context" => <>.into(),
    "Reactions" => <>.into(),
    "Weights" => <>.into(),
    "Sets" => <>.into(),
    "Print" => <>.into(),
    "Save" => <>.into(),
    "Dot" => <>.into(),
    "GraphML" => <>.into(),
    "Serialize" => <>.into(),
    "Stats" => <>.into(),
    "Target" => <>.into(),
    "Run" => <>.into(),
    "Loop" => <>.into(),
    "Frequency" => <>.into(),
    "LimitFrequency" => <>.into(),
    "FastFrequency" => <>.into(),
    "Digraph" => <>.into(),
    "Bisimilarity" => <>.into(),
    "Deserialize" => <>.into(),
    "Hide" => <>.into(),
    "Entities" => <>.into(),
    "MaskEntities" => <>.into(),
    "UncommonEntities" => <>.into(),
    "UncommonMaskEntities" => <>.into(),
    "MaskContext" => <>.into(),
    "UncommonContext" => <>.into(),
    "UncommonMaskContext" => <>.into(),
    "Products" => <>.into(),
    "MaskProducts" => <>.into(),
    "UncommonProducts" => <>.into(),
    "UncommonMaskProducts" => <>.into(),
    "Union" => <>.into(),
    "MaskUnion" => <>.into(),
    "UncommonUnion" => <>.into(),
    "UncommonMaskUnion" => <>.into(),
    "Difference" => <>.into(),
    "MaskDifference" => <>.into(),
    "UncommonDifference" => <>.into(),
    "UncommonMaskDifference" => <>.into(),
    "EntitiesDeleted" => <>.into(),
    "MaskEntitiesDeleted" => <>.into(),
    "UncommonEntitiesDeleted" => <>.into(),
    "UncommonMaskEntitiesDeleted" => <>.into(),
    "EntitiesAdded" => <>.into(),
    "MaskEntitiesAdded" => <>.into(),
    "UncommonEntitiesAdded" => <>.into(),
    "UncommonMaskEntitiesAdded" => <>.into(),
    "label" => <>.into(),
    "edge" => <>.into(),
    "if" => <>.into(),
    "then" => <>.into(),
    "else" => <>.into(),
    "let" => <>.into(),
    "return" => <>.into(),
    "for" => <>.into(),
    "in" => <>.into(),
    "not" => <>.into(),
    "rand" => <>.into(),
    "empty" => <>.into(),
    "length" => <>.into(),
    "tostr" => <>.into(),
    "source" => <>.into(),
    "target" => <>.into(),
    "substr" => <>.into(),
    "min" => <>.into(),
    "max" => <>.into(),
    "commonsubstr" => <>.into(),
    "SystemEntities" => <>.into(),
    "SystemContext" => <>.into(),
    "AvailableEntities" => <>.into(),
    "AllReactants" => <>.into(),
    "AllInhibitors" => <>.into(),
    "relabel" => <>.into(),
};

// all numbers are i64
Num: i64 = {
    NUMBER =>? i64::from_str(<>)
	       .map_err(|_| ParseError::User { error: "Number is too big" })
};

Path: String = {
    PATH => <>.trim_end_matches("\"").trim_start_matches("\"").to_string()
};

// macro for matching sequence of patterns with C as separator
Separated<T, C>: Vec<T> = {
    <mut v:(<T> C)+> <e:T?> => match e {
	None => v,
	Some(e) => {
	    v.push(e);
	    v
	}
    }
};

Separated_Or<T, C>: Vec<T> = {
    <v: T> => vec![v],
    <v: Separated<T, C>> => v
}

// -----------------------------------------------------------------------------
//                                 SetParser
// -----------------------------------------------------------------------------
pub Set: RSset = {
    <s: Set_of_entities> => s
};

Set_of_entities: RSset = {
    "{" "}" => RSset::from(vec![]),
    "{" <t: Separated_Or<Literal, ",">> "}" =>
	RSset::from(t.into_iter().map(|t| translator.encode(t))
						    .collect::<Vec<_>>())
};


// -----------------------------------------------------------------------------
//                               ReactionParser
// -----------------------------------------------------------------------------

pub Reactions: Vec<RSreaction> = {
    "(" ")" => vec![],
    "(" <s: Separated_Or<Reaction, ";">> ")" => s
}

Reaction: RSreaction = {
    #[precedence(level="1")]
    "[" <r: Set> "," <i: Set> "," <p: Set> "]" => RSreaction::from(r, i, p),

    #[precedence(level="0")]
    "[" "r:" <r: Set> "," "i:" <i: Set> "," "p:" <p: Set> "]" =>
	RSreaction::from(r, i, p),
}


// -----------------------------------------------------------------------------
//                               ContextParser
// -----------------------------------------------------------------------------
pub Context: RSprocess = {
    "[" "]" => RSprocess::NondeterministicChoice{ children: vec![] },
    "[" <t: Separated_Or<Boxed_CTX_process, ",">> "]" =>
	RSprocess::NondeterministicChoice{ children: t }
};

Boxed_CTX_process: Rc<RSprocess> = {
    <t: CTX_process> => Rc::new(t)
}

CTX_process: RSprocess = {
    "nill" => RSprocess::Nill,

    <c: Set_of_entities> "." <k: CTX_process> =>
	RSprocess::EntitySet{ entities: c, next_process: Rc::new(k) },

    "(" <k: CTX_process>  ")" => k,

    "(" <k: Separated<CTX_process, "+">> ")" =>
	RSprocess::Summation{
		children: k.into_iter().map(Rc::new).collect::<Vec<_>>()
	},

    "?" <r: Reaction> "?" "." <k: CTX_process> =>
	RSprocess::Guarded{ reaction: r, next_process: Rc::new(k) },

    "<" <n: Num> "," <k1: CTX_process> ">" "." <k: CTX_process> =>
	RSprocess::WaitEntity{ repeat: n,
			       repeated_process: Rc::new(k1),
			       next_process: Rc::new(k) },

    <identifier: LiteralProcess> =>
	RSprocess::RecursiveIdentifier{
		identifier: translator.encode(identifier)
	}
};


// -----------------------------------------------------------------------------
//                             EnvironmentParser
// -----------------------------------------------------------------------------
pub Environment: Box<RSenvironment> = {
    "[" "]" => Box::new(RSenvironment::new()),
    "[" <t: Separated_Or<Env_term, ",">> "]" => Box::new(RSenvironment::from(t))
};

Env_term: (IdType, RSprocess) = {
    <identifier: LiteralProcess> "=" <k: CTX_process> =>
	(translator.encode(identifier), k)
};


// -----------------------------------------------------------------------------
//                                AssertParser
// -----------------------------------------------------------------------------
pub Assert: Box<rsassert::RSassert> = {
     "label" "{" <f: AssertTree> "}" =>
	Box::new(rsassert::RSassert{tree: f}),
};

AssertTree: rsassert::Tree = {
    <t1: AssertTree2> ";" <t2: AssertTree> =>
	rsassert::Tree::Concat(Box::new(t1), Box::new(t2)),
    <t: AssertTree2> => t,
}

AssertTree2: rsassert::Tree = {
    #[precedence(level="1")]
    "if" <e: AssertExpression>
    "then" "{" <t: AssertTree> "}" =>
	rsassert::Tree::If(Box::new(e), Box::new(t)),

    #[precedence(level="0")]
    "if" <e: AssertExpression>
    "then" "{" <t1: AssertTree> "}"
    "else" "{" <t2: AssertTree> "}" =>
	rsassert::Tree::IfElse(Box::new(e), Box::new(t1), Box::new(t2)),

    #[precedence(level="2")]
    "let" <v: AssertVariable> <q: AssertQualifier?> "=" <e: AssertExpression> =>
	rsassert::Tree::Assignment(v, q, Box::new(e)),

    #[precedence(level="3")]
    "return" <e: AssertExpression> =>
	rsassert::Tree::Return(Box::new(e)),

    #[precedence(level="4")]
    "for" <v: AssertVariable> "in" <r: AssertRange> "{" <t: AssertTree> "}" =>
	rsassert::Tree::For(v, r, Box::new(t)),
}

AssertVariable: rsassert::Variable = {
    #[precedence(level="0")]
    "label" => rsassert::Variable::Special(rsassert::Special::Label),
    #[precedence(level="1")]
    "edge"  => rsassert::Variable::Special(rsassert::Special::Edge),
    #[precedence(level="2")]
    <v: Literal> => rsassert::Variable::Id(v),
}


AssertExpression: rsassert::Expression = {
    // Unary
    #[precedence(level="0")]
    <unp: AssertUnaryPrefix> <e: AssertExpression> =>
	rsassert::Expression::Unary(unp, Box::new(e)),
    #[precedence(level="2")]
    <e: AssertExpression> <uns: AssertUnarySuffix> =>
	rsassert::Expression::Unary(uns, Box::new(e)),

    // binary
    #[precedence(level="3")] #[assoc(side="left")]
    <e1: AssertExpression> <b: AssertBinary> <e2: AssertExpression> =>
	rsassert::Expression::Binary(b, Box::new(e1), Box::new(e2)),
    #[precedence(level="1")]
    <b: AssertBinaryPrefix>
    "(" <e1: AssertExpression> "," <e2: AssertExpression> ")" =>
	rsassert::Expression::Binary(b, Box::new(e1), Box::new(e2)),

    #[precedence(level="4")]
    "(" <e: AssertExpression> ")" => e,
    "true" => rsassert::Expression::True,
    "false" => rsassert::Expression::False,

    #[precedence(level="5")]
    <v: AssertVariable> => rsassert::Expression::Var(v),

    // If changing IntegerType in assert.rs, also change from Num to another
    // similar parser with different return type
    #[precedence(level="6")]
    <i: Num> => rsassert::Expression::Integer(i),

    #[precedence(level="7")]
    <lab: AssertLabel> => rsassert::Expression::Label(Box::new(lab)),
    <set: Set_of_entities> => rsassert::Expression::Set(set),
    "'" <el: Literal> "'" => rsassert::Expression::Element(translator.encode(el)),

    // strings
    #[precedence(level="8")]
    PATH => rsassert::Expression::String(<>.trim_end_matches("\"")
					 .trim_start_matches("\"")
					 .to_string()),
}

AssertRange: rsassert::Range = {
    "{" <e: AssertExpression> "}" => rsassert::Range::IterateOverSet(Box::new(e)),
    "{" <e1: AssertExpression> ".." <e2: AssertExpression> "}" =>
	rsassert::Range::IterateInRange(Box::new(e1), Box::new(e2)),
}

AssertUnaryPrefix: rsassert::Unary = {
    "not" => rsassert::Unary::Not,
    "rand" => rsassert::Unary::Rand,
}

AssertUnarySuffix: rsassert::Unary = {
    #[precedence(level="0")]
    "." "empty" => rsassert::Unary::Empty,
    "." "length" => rsassert::Unary::Length,
    "." "tostr" => rsassert::Unary::ToStr,
    "." "toel" => rsassert::Unary::ToEl,

    #[precedence(level="1")]
    "." <q: AssertQualifier> => rsassert::Unary::Qualifier(q),
}

AssertQualifierRestricted: rsassert::QualifierRestricted = {
    "Entities" => rsassert::QualifierRestricted::Entities,
    "Context" => rsassert::QualifierRestricted::Context,
    "Reactants" => rsassert::QualifierRestricted::Reactants,
    "ReactantsAbsent" => rsassert::QualifierRestricted::ReactantsAbsent,
    "Inhibitors" => rsassert::QualifierRestricted::Inhibitors,
    "InhibitorsPresent" => rsassert::QualifierRestricted::InhibitorsPresent,
    "Products" => rsassert::QualifierRestricted::Products,
}

AssertQualifierLabel: rsassert::QualifierLabel = {
    "AvailableEntities" => rsassert::QualifierLabel::AvailableEntities,
    "AllReactants" => rsassert::QualifierLabel::AllReactants,
    "AllInhibitors" => rsassert::QualifierLabel::AllInhibitors,
}

AssertQualifierSystem: rsassert::QualifierSystem = {
    "SystemEntities" => rsassert::QualifierSystem::Entities,
    "SystemContext" => rsassert::QualifierSystem::Context,
}

AssertQualifierEdge: rsassert::QualifierEdge = {
    "source" => rsassert::QualifierEdge::Source,
    "target" => rsassert::QualifierEdge::Target,
}

AssertQualifierNode: rsassert::QualifierNode = {
    "neighbours" => rsassert::QualifierNode::Neighbours,
    "system" => rsassert::QualifierNode::System,
}

AssertQualifier: rsassert::Qualifier = {
    <q: AssertQualifierSystem> => rsassert::Qualifier::System(q),
    <q: AssertQualifierLabel> => rsassert::Qualifier::Label(q),
    <q: AssertQualifierRestricted> => rsassert::Qualifier::Restricted(q),
    <q: AssertQualifierEdge> => rsassert::Qualifier::Edge(q),
    <q: AssertQualifierNode> => rsassert::Qualifier::Node(q),
}


AssertBinary: rsassert::Binary = {
    "&&" => rsassert::Binary::And,
    "||" => rsassert::Binary::Or,
    "^^" => rsassert::Binary::Xor,
    "<" => rsassert::Binary::Less,
    "<=" => rsassert::Binary::LessEq,
    ">" => rsassert::Binary::More,
    ">=" => rsassert::Binary::MoreEq,
    "==" => rsassert::Binary::Eq,
    "!=" => rsassert::Binary::NotEq,
    "+" => rsassert::Binary::Plus,
    "-" => rsassert::Binary::Minus,
    "*" => rsassert::Binary::Times,
    "^" => rsassert::Binary::Exponential,
    "/" => rsassert::Binary::Quotient,
    "%" => rsassert::Binary::Reminder,
    "::" => rsassert::Binary::Concat,
}

AssertBinaryPrefix: rsassert::Binary = {
    "substr" => rsassert::Binary::SubStr,
    "min" => rsassert::Binary::Min,
    "max" => rsassert::Binary::Max,
    "commonsubstr" => rsassert::Binary::CommonSubStr,
}


AssertLabel: RSlabel = {
    "["
       "Entities" ":" <e: Set_of_entities> ","
       "Context" ":" <c: Set_of_entities> ","
       "Reactants" ":" <r: Set_of_entities> ","
       "ReactantsAbsent" ":" <r_a: Set_of_entities> ","
       "Inhibitors" ":" <i: Set_of_entities> ","
       "InhibitorsPresent" ":" <i_p: Set_of_entities> ","
       "Products" ":" <p: Set_of_entities> ","
    "]" => RSlabel::create(e, c, r, r_a, i, i_p, p)
}

// -----------------------------------------------------------------------------
//                                 BHMLParser
// -----------------------------------------------------------------------------
// pub BHML: Box<RSBHML> = {
//     <g: Formula_BHML> => Box::new(g)
// };

// Formula_BHML: RSBHML = {
//     "true" => RSBHML::True,
//     "false" => RSBHML::False,
//     "(" <g: Separated<Formula_BHML, "\\/">> ")" => RSBHML::Or(g),
//     "(" <g: Separated<Formula_BHML, "/\\">> ")" => RSBHML::And(g),
//     "<" <f: Formula_Assert> ">" <g: Formula_BHML> =>
//	RSBHML::Diamond(Box::new(f), Box::new(g)),
//     "[" <f: Formula_Assert> "]" <g: Formula_BHML> =>
//	RSBHML::Box(Box::new(f), Box::new(g)),
// };


// ----------------------------------------------------------------------------
//                                File Parsing
// ----------------------------------------------------------------------------

// system
// a system is an environment, a set of entities as initial state, a context and
// a set of reaction rules.
pub System: RSsystem = {
    "Environment" ":" <delta: Environment>
    "Initial Entities" ":" <available_entities: Set>
    "Context" ":" <context_process: Context>
    "Reactions" ":" <reaction_rules: Reactions>
	=> RSsystem::from(delta.into(),
			  available_entities,
			  context_process,
			  Rc::new(reaction_rules))
}

// experiment
// an experiment is composed by a sequence of weights and a sequence of sets of
// entities of equal length.
pub Experiment: (Vec<u32>, Vec<RSset>) = {
    "Weights" ":" <w: Separated_Or<Num, ",">>
    "Sets" ":" <s: Separated_Or<Set_of_entities, ",">>
	=> (w.into_iter().map(|x| x as u32).collect::<Vec<_>>(), s),
}


// ~~~~~~~~~~~~~~~~~~~
// Instruction Parsing
// ~~~~~~~~~~~~~~~~~~~

/// Decides whetherer to print to stdout or to save to file
Helper_SO: presets::SaveOptions = {
    "Print" =>
	presets::SaveOptions {print: true, save: None},
    "Save" "(" <p: Path> ")" =>
	presets::SaveOptions {print: false, save: Some(vec![p])}
}

/// we could need to save to multiple files
SaveOptions: presets::SaveOptions = {
    <p: Separated_Or<Helper_SO, ";">> => {
	p.into_iter()
	 .reduce(|mut acc, mut e| {acc.combine(&mut e); acc})
	 .unwrap_or_default()
    }
}

/// Match for strings between nodes formatters
LiteralSeparatorNode: graph::NodeDisplayBase = {
    PATH =>
	graph::NodeDisplayBase::String {
	    string: <>.trim_end_matches("\"")
		      .trim_start_matches("\"")
		      .to_string()
	}
};

/// Match for strings between edge formatters
LiteralSeparatorEdge: graph::EdgeDisplayBase = {
    PATH =>
	graph::EdgeDisplayBase::String {
	    string: <>.trim_end_matches("\"")
		      .trim_start_matches("\"")
		      .to_string()
	}
};

NodeDisplayBase: graph::NodeDisplayBase = {
    "Hide" =>
	graph::NodeDisplayBase::Hide,
    "Entities" =>
	graph::NodeDisplayBase::Entities,
    "MaskEntities" <mask: Set> =>
	graph::NodeDisplayBase::MaskEntities{mask},
    "ExcludeEntities" <mask: Set> =>
      graph::NodeDisplayBase::ExcludeEntities{mask},
    "Context" =>
	graph::NodeDisplayBase::Context,
    "UncommonEntities" =>
	graph::NodeDisplayBase::UncommonEntities,
    "MaskUncommonentities" <mask: Set> =>
	graph::NodeDisplayBase::MaskUncommonEntities{mask},
}

/// Node display formatters separated by arbitrary strings in quotes
SeparatorNode: graph::NodeDisplay = {
    <v: NodeDisplayBase> => graph::NodeDisplay {base: vec![v]},
    <v:(<NodeDisplayBase> <LiteralSeparatorNode>)+> <e: NodeDisplayBase?> =>
	match e {
	    None => graph::NodeDisplay {
			base:
			v.iter().fold(vec![],
			    |mut acc, (a, b)| {
				acc.push(a.clone());
				acc.push(b.clone());
				acc.clone()
			    })
			},
	    Some(e) => {
		let mut v = v.iter().fold(vec![],
					  |mut acc, (a, b)| {
					      acc.push(a.clone());
					      acc.push(b.clone());
					      acc.clone()
					  });
		v.push(e);
		graph::NodeDisplay { base: v }
	    }
	}
}

EdgeDisplay: graph::EdgeDisplayBase = {
    "Hide" =>
	graph::EdgeDisplayBase::Hide,

    "Products" =>
	graph::EdgeDisplayBase::Products
	{ mask: None, filter_common: false },
    "MaskProducts" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: false },
    "UncommonProducts" =>
	graph::EdgeDisplayBase::Products
	{ mask: None, filter_common: true },
    "UncommonMaskProducts" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: true },

    "Entities" =>
	graph::EdgeDisplayBase::Entities
	{ mask: None, filter_common: false },
    "MaskEntities" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: false },
    "UncommonEntities" =>
	graph::EdgeDisplayBase::Entities
	{ mask: None, filter_common: true },
    "UncommonMaskEntities" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: true },

    "Context" =>
	graph::EdgeDisplayBase::Context
	{ mask: None, filter_common: false },
    "MaskContext" <mask: Set> =>
	graph::EdgeDisplayBase::Context
	{ mask: Some(mask), filter_common: false },
    "UncommonContext" =>
	graph::EdgeDisplayBase::Context
	{ mask: None, filter_common: true },
    "UncommonMaskContext" <mask: Set> =>
	graph::EdgeDisplayBase::Context
	{ mask: Some(mask), filter_common: true },

    "Union" =>
	graph::EdgeDisplayBase::Union
	{ mask: None, filter_common: false },
    "MaskUnion" <mask: Set> =>
	graph::EdgeDisplayBase::Union
	{ mask: Some(mask), filter_common: false },
    "UncommonUnion" =>
	graph::EdgeDisplayBase::Union
	{ mask: None, filter_common: true },
    "UncommonMaskUnion" <mask: Set> =>
	graph::EdgeDisplayBase::Union
	{ mask: Some(mask), filter_common: true },

    "Difference" =>
	graph::EdgeDisplayBase::Difference
	{ mask: None, filter_common: false },
    "MaskDifference" <mask: Set> =>
	graph::EdgeDisplayBase::Difference
	{ mask: Some(mask), filter_common: false },
    "UncommonDifference" =>
	graph::EdgeDisplayBase::Difference
	{ mask: None, filter_common: true },
    "UncommonMaskDifference" <mask: Set> =>
	graph::EdgeDisplayBase::Difference
	{ mask: Some(mask), filter_common: true },

    "EntitiesDeleted" =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: None, filter_common: false },
    "MaskEntitiesDeleted" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: Some(mask), filter_common: false },
    "UncommonEntitiesDeleted" =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: None, filter_common: true },
    "UncommonMaskEntitiesDeleted" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: Some(mask), filter_common: true },

    "EntitiesAdded" =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: None, filter_common: false },
    "MaskEntitiesAdded" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: Some(mask), filter_common: false },
    "UncommonEntitiesAdded" =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: None, filter_common: true },
    "UncommonMaskEntitiesAdded" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: Some(mask), filter_common: true },
}

/// Edge display formatters separated by arbitrary strings in quotes
SeparatorEdge: graph::EdgeDisplay = {
    <v: EdgeDisplay> => graph::EdgeDisplay{ base: vec![v] },
    <v:(<EdgeDisplay> <LiteralSeparatorEdge>)+> <e: EdgeDisplay?> =>
	match e {
	    None => graph::EdgeDisplay{ base: v.iter().fold(vec![],
					      |mut acc, (a, b)| {
						  acc.push(a.clone());
						  acc.push(b.clone());
						  acc.clone()
					      }) },
	    Some(e) => {
		let mut v = v.iter().fold(vec![],
					  |mut acc, (a, b)| {
					      acc.push(a.clone());
					      acc.push(b.clone());
					      acc.clone()
					  });
		v.push(e);
		graph::EdgeDisplay{ base: v }
	    }
	}
}

Operation: graph::OperationType = {
    "==" => graph::OperationType::Equals,
    "="  => graph::OperationType::Equals,
    "<"  => graph::OperationType::Subset,
    "⊂"  => graph::OperationType::Subset,
    "<=" => graph::OperationType::SubsetEqual,
    "⊆"  => graph::OperationType::SubsetEqual,
    ">"  => graph::OperationType::Superset,
    "⊃"  => graph::OperationType::Superset,
    ">=" => graph::OperationType::SupersetEqual,
    "⊇"  => graph::OperationType::SupersetEqual
}

NodeColorConditional: (graph::NodeColorConditional, String) = {
    "Entities" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::NodeColorConditional::EntitiesConditional(op, set),
	    color.to_string()),
    "Context.Nill" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::Nill),
	    color.to_string()),
    "Context.RecursiveIdentifier" "(" <x: Literal> ")" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::RecursiveIdentifier(
		translator.encode(x)
	    )),
	    color.to_string()),
    "Context.EntitySet" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::EntitySet(op, set)),
	    color.to_string()),
    "Context.NonDeterministicChoice" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::NonDeterministicChoice),
	    color.to_string()),
    "Context.Summation" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::Summation),
	    color.to_string()),
    "Context.WaitEntity" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::WaitEntity),
	    color.to_string()),
}


/// Node color formatter
ColorNode: graph::NodeColor = {
    <conditionals: Separated_Or<NodeColorConditional, "||">>
    "!" <base_color: PATH> =>
	graph::NodeColor { conditionals,
			   base_color: base_color.to_string() },

    "!" <base_color: PATH> =>
	graph::NodeColor { conditionals: vec![],
			   base_color: base_color.to_string() },
}

EdgeColorConditional: (graph::EdgeColorConditional, String) = {
    "Entities" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Entities(op, set),
	    color.to_string()),
    "Context" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Context(op, set),
	    color.to_string()),
    "T" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::T(op, set),
	    color.to_string()),
    "Reactants" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Reactants(op, set),
	    color.to_string()),
    "AbsentReactants" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::ReactantsAbsent(op, set),
	    color.to_string()),
    "Inhibitors" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Inhibitors(op, set),
	    color.to_string()),
    "PresentInhibitors" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::InhibitorsPresent(op, set),
	    color.to_string()),
    "Products" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Products(op, set),
	    color.to_string()),
}

ColorEdge: graph::EdgeColor = {
    <conditionals: Separated_Or<EdgeColorConditional, "||">>
    "!" <base_color: PATH> =>
	graph::EdgeColor { conditionals,
			   base_color: base_color.to_string() },

    "!" <base_color: PATH> =>
	graph::EdgeColor { conditionals: vec![],
			   base_color: base_color.to_string() },
}


GraphSaveOptions: presets::GraphSaveOptions = {
    "Dot" "|"? <s_node: SeparatorNode> "|" <s_edge: SeparatorEdge> "|"
	  <c_node: ColorNode> "|" <c_edge: ColorEdge> ">"
	<so: SaveOptions> =>
	presets::GraphSaveOptions::Dot { node_display: s_node,
					 edge_display: s_edge,
					 node_color:   c_node,
					 edge_color:   c_edge,
					 so },
    "GraphML" "|"? <s_node: SeparatorNode> "|" <s_edge: SeparatorEdge> ">"
	<so: SaveOptions> =>
	presets::GraphSaveOptions::GraphML { node_display: s_node,
					     edge_display: s_edge,
					     so },
    "Serialize" "(" <path: Path> ")" =>
	presets::GraphSaveOptions::Serialize { path },
}


Instruction: presets::Instruction = {
    "Stats" ">" <so: SaveOptions> =>
	presets::Instruction::Stats { so },
    "Target" ">" <so: SaveOptions> =>
	presets::Instruction::Target { so },
    "Run" ">" <so: SaveOptions> =>
	presets::Instruction::Run { so },
    "Loop" "(" <symbol: Literal> ")" ">" <so: SaveOptions> =>
	presets::Instruction::Loop { symbol,  so },
    "Frequency" ">" <so: SaveOptions> =>
	presets::Instruction::Frequency { so },
    "LimitFrequency" "(" <p: Path> ")" ">" <so: SaveOptions> =>
	presets::Instruction::LimitFrequency { experiment: p, so },
    "FastFrequency" "(" <p: Path> ")" ">" <so: SaveOptions> =>
	presets::Instruction::FastFrequency { experiment: p, so },
    "Digraph" ">" <gso: Separated_Or<GraphSaveOptions, "|">> =>
	presets::Instruction::Digraph { gso },
    // <edge_relabeler: Assert>
    "Bisimilarity" "(" <p: Path> ")" "relabel" <edge_relabeler: Assert>
    ">" <so: SaveOptions> =>
	presets::Instruction::Bisimilarity {
	    system_b: p,
	    edge_relabeler,
	    so
	},
}

pub Run: presets::Instructions = {
    #[precedence(level="0")]
    <sys: System> <instr: Separated_Or<Instruction, ",">> =>
	Instructions { system: presets::System::RSsystem { sys },
		       instructions: instr },

    #[precedence(level="1")]
    <sys: System> =>
	Instructions { system: presets::System::RSsystem { sys },
		       instructions: vec![] },

    #[precedence(level="2")]
    "Deserialize" "(" <path: Path> ")"
    <instr: Separated_Or<Instruction, ",">> =>
	Instructions { system: presets::System::Deserialize { path },
		       instructions: instr },
}
