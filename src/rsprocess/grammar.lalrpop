use std::rc::Rc;
use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::rsprocess::structure::{RSset,
				  RSprocess,
				  RSenvironment,
				  RSsystem,
				  RSlabel,
				  RSreaction};
use crate::rsprocess::structure::assert;
use crate::rsprocess::translator::{Translator, IdType};
use crate::rsprocess::presets::Instructions;
use crate::rsprocess::presets;
use crate::rsprocess::graph;

grammar(translator: &mut Translator);

// -----------------------------------------------------------------------------
//                                  Helpers
// -----------------------------------------------------------------------------

// order
match {
    ".", ",", ";",
    "nill",
    "{", "}",
    "[", "]",
    "(", ")",
    "<", ">",
    "r:", "i:", "p:",
    "-", "^",
    "true", "false",
    "Environment", "Initial Entities", "Context", "Reactions",
    "Weights", "Sets",
    "Print", "Save",
    "Dot", "GraphML", "Serialize",
    "Stats", "Target", "Run", "Loop", "Frequency", "LimitFrequency",
    "FastFrequency", "Digraph", "Bisimilarity",
    "Deserialize",
    "?",
    "Hide",
    "Entities", "MaskEntities", "UncommonEntities", "UncommonMaskEntities",
    "MaskContext", "UncommonContext", "UncommonMaskContext",
    "Products", "MaskProducts", "UncommonProducts", "UncommonMaskProducts",
    "Union", "MaskUnion", "UncommonUnion", "UncommonMaskUnion",
    "Difference", "MaskDifference",
	"UncommonDifference", "UncommonMaskDifference",
    "EntitiesDeleted", "MaskEntitiesDeleted",
	"UncommonEntitiesDeleted", "UncommonMaskEntitiesDeleted",
    "EntitiesAdded", "MaskEntitiesAdded",
	"UncommonEntitiesAdded", "UncommonMaskEntitiesAdded",
    "label", "if", "then", "else", "let", "=", "return", "for", "in",
    "not", "rand", ".empty", ".length", ".tostr",
    "&&", "||", "^^", "<=", ">=", "==", "!=", "+", "*", "/", "%",
    "::", "substr", "min", "max", "commonsubstr",
    "AvailableEntities", "AllReactants", "AllInhibitors",
} else {
    r"[0-9]+" => NUMBER
} else {
    r"([[:alpha:]])([[:word:]])*" => WORD
    // r"(\p{L}|\p{Emoji})(\p{L}|\p{Emoji}|\p{Dash}|\p{N})*" => WORD,
} else {
    r#""[^"]+""# => PATH, // " <- ignore comment, its for the linter in emacs
} else {
    _
}


// matches words (letter followed by numbers, letters or _)
Literal: String = {
    WORD => <>.to_string()
};

// all numbers are i64
Num: i64 = {
    NUMBER =>? i64::from_str(<>)
		  .map_err(|_| ParseError::User { error: "Number is too big" })
};

Path: String = {
    PATH => <>.trim_end_matches("\"").trim_start_matches("\"").to_string()
};

// macro for matching sequence of patterns with C as separator
Separated<T, C>: Vec<T> = {
    <mut v:(<T> C)+> <e:T?> => match e {
	None => v,
	Some(e) => {
	    v.push(e);
	    v
	}
    }
};

Separated_Or<T, C>: Vec<T> = {
    <v: T> => vec![v],
    <v: Separated<T, C>> => v
}

// -----------------------------------------------------------------------------
//                                 SetParser
// -----------------------------------------------------------------------------
pub Set: RSset = {
    <s: Set_of_entities> => s
};

Set_of_entities: RSset = {
    "{" "}" => RSset::from(vec![]),
    "{" <t: Separated_Or<Literal, ",">> "}" =>
	RSset::from(t.into_iter().map(|t| translator.encode(t))
						    .collect::<Vec<_>>())
};


// -----------------------------------------------------------------------------
//                               ReactionParser
// -----------------------------------------------------------------------------

pub Reactions: Vec<RSreaction> = {
    "(" ")" => vec![],
    "(" <s: Separated_Or<Reaction, ";">> ")" => s
}

Reaction: RSreaction = {
    "[" <r: Set> "," <i: Set> "," <p: Set> "]" => RSreaction::from(r, i, p),
    "[" "r:" <r: Set> "," "i:" <i: Set> "," "p:" <p: Set> "]" =>
	RSreaction::from(r, i, p),
}


// -----------------------------------------------------------------------------
//                               ContextParser
// -----------------------------------------------------------------------------
pub Context: RSprocess = {
    "[" "]" => RSprocess::NondeterministicChoice{ children: vec![] },
    "[" <t: Separated_Or<Boxed_CTX_process, ",">> "]" =>
	RSprocess::NondeterministicChoice{ children: t }
};

Boxed_CTX_process: Rc<RSprocess> = {
    <t: CTX_process> => Rc::new(t)
}

CTX_process: RSprocess = {
    "nill" => RSprocess::Nill,
    <c: Set_of_entities> "." <k: CTX_process> =>
	RSprocess::EntitySet{ entities: c, next_process: Rc::new(k) },
    "(" <k: CTX_process>  ")" => k,
    "(" <k: Separated<CTX_process, "+">> ")" =>
	RSprocess::Summation{
		children: k.into_iter().map(Rc::new).collect::<Vec<_>>()
	},
    "<" <n: Num> <k1: CTX_process> ">" "." <k: CTX_process> =>
	RSprocess::WaitEntity{ repeat: n,
			       repeated_process: Rc::new(k1),
			       next_process: Rc::new(k) },
    <identifier: Literal> =>
	RSprocess::RecursiveIdentifier{
		identifier: translator.encode(identifier)
	}
};


// -----------------------------------------------------------------------------
//                             EnvironmentParser
// -----------------------------------------------------------------------------
pub Environment: Box<RSenvironment> = {
    "[" "]" => Box::new(RSenvironment::new()),
    "[" <t: Separated_Or<Env_term, ",">> "]" => Box::new(RSenvironment::from(t))
};

Env_term: (IdType, RSprocess) = {
    <identifier: Literal> "=" <k: CTX_process> =>
	(translator.encode(identifier), k)
};


// -----------------------------------------------------------------------------
//                                AssertParser
// -----------------------------------------------------------------------------
pub Assert: Box<assert::RSassert> = {
    "label" "{" <f: AssertTree> "}" =>
	Box::new(assert::RSassert{tree: f}),
};

AssertTree: assert::Tree = {
    <t1: AssertTree2> ";" <t2: AssertTree> =>
	assert::Tree::Concat(Box::new(t1), Box::new(t2)),
    <t: AssertTree2> => t,
}

AssertTree2: assert::Tree = {
    "if" <e: AssertExpression>
    "then" "{" <t: AssertTree> "}" =>
	assert::Tree::If(Box::new(e), Box::new(t)),

    "if" <e: AssertExpression>
    "then" "{" <t1: AssertTree> "}"
    "else" "{" <t2: AssertTree> "}" =>
	assert::Tree::IfElse(Box::new(e), Box::new(t1), Box::new(t2)),

    "let" <v: AssertAssignmentVar> "=" <e: AssertExpression> =>
	assert::Tree::Assignment(v, Box::new(e)),

    "return" <e: AssertExpression> =>
	assert::Tree::Return(Box::new(e)),

    "for" <v: AssertVariable> "in" <r: AssertRange> "{" <t: AssertTree> "}" =>
	assert::Tree::For(v, r, Box::new(t)),
}

AssertAssignmentVar: assert::AssignmentVariable = {
    <v: AssertVariable> => assert::AssignmentVariable::Var(v),
    <v: AssertVariable> "." <q: AssertQualifierRestricted> =>
	assert::AssignmentVariable::QualifiedVar(v, q),
}

AssertVariable: assert::Variable = {
    "label" => assert::Variable::Label,
    <v: Literal> => assert::Variable::Id(v),
}

AssertExpression: assert::Expression = {
    <unp: AssertUnaryPrefix> <e: AssertExpression> =>
	assert::Expression::Unary(unp, Box::new(e)),
    "(" <e: AssertExpression> ")" <uns: AssertUnarySuffix> =>
	assert::Expression::Unary(uns, Box::new(e)),

    "(" <e1: AssertExpression> <b: AssertBinary> <e2: AssertExpression> ")" =>
	assert::Expression::Binary(b, Box::new(e1), Box::new(e2)),
    <b: AssertBinaryPrefix>
    "(" <e1: AssertExpression> "," <e2: AssertExpression> ")" =>
	assert::Expression::Binary(b, Box::new(e1), Box::new(e2)),

    "(" <e: AssertExpression> ")" => e,
    "true" => assert::Expression::True,
    "false" => assert::Expression::False,

    <v: AssertAssignmentVar> => assert::Expression::Var(v),

    // If changing IntegerType in assert.rs, also change from Num to another
    // similar parser with different return type
    <i: Num> => assert::Expression::Integer(i),

    <lab: AssertLabel> => assert::Expression::Label(Box::new(lab)),
    <set: Set_of_entities> => assert::Expression::Set(set),
    "'" <el: Literal> "'" => assert::Expression::Element(translator.encode(el)),

    // strings
    PATH => assert::Expression::String(<>.trim_end_matches("\"")
					 .trim_start_matches("\"")
					 .to_string()),
}

AssertUnaryPrefix: assert::Unary = {
    "not" => assert::Unary::Not,
    "rand" => assert::Unary::Rand,
}

AssertUnarySuffix: assert::Unary = {
    ".empty" => assert::Unary::Empty,
    ".length" => assert::Unary::Length,
    ".tostr" => assert::Unary::ToStr,
    "." <q: AssertQualifier> => assert::Unary::Qualifier(q),
}

AssertBinary: assert::Binary = {
    "&&" => assert::Binary::And,
    "||" => assert::Binary::Or,
    "^^" => assert::Binary::Xor,
    "<" => assert::Binary::Less,
    "<=" => assert::Binary::LessEq,
    ">" => assert::Binary::More,
    ">=" => assert::Binary::MoreEq,
    "==" => assert::Binary::Eq,
    "!=" => assert::Binary::NotEq,
    "+" => assert::Binary::Plus,
    "-" => assert::Binary::Minus,
    "*" => assert::Binary::Times,
    "^" => assert::Binary::Exponential,
    "/" => assert::Binary::Quotient,
    "%" => assert::Binary::Reminder,
    "::" => assert::Binary::Concat,
}

AssertBinaryPrefix: assert::Binary = {
    "substr" => assert::Binary::SubStr,
    "min" => assert::Binary::Min,
    "max" => assert::Binary::Max,
    "commonsubstr" => assert::Binary::CommonSubStr,
}

AssertQualifier: assert::Qualifier = {
    "AvailableEntities" => assert::Qualifier::AvailableEntities,
    "AllReactants" => assert::Qualifier::AllReactants,
    "AllInhibitors" => assert::Qualifier::AllInhibitors,
    <q: AssertQualifierRestricted> => assert::Qualifier::Restricted(q),
}

AssertQualifierRestricted: assert::QualifierRestricted = {
    "Entities" => assert::QualifierRestricted::Entities,
    "Context" => assert::QualifierRestricted::Context,
    "Reactants" => assert::QualifierRestricted::Reactants,
    "ReactantsAbsent" => assert::QualifierRestricted::ReactantsAbsent,
    "Inhibitors" => assert::QualifierRestricted::Inhibitors,
    "InhibitorsPresent" => assert::QualifierRestricted::InhibitorsPresent,
    "Products" => assert::QualifierRestricted::Products,
}

AssertLabel: RSlabel = {
    "["
       "Entities" ":" <e: Set_of_entities> ","
       "Context" ":" <c: Set_of_entities> ","
       "Reactants" ":" <r: Set_of_entities> ","
       "ReactantsAbsent" ":" <r_a: Set_of_entities> ","
       "Inhibitors" ":" <i: Set_of_entities> ","
       "InhibitorsPresent" ":" <i_p: Set_of_entities> ","
       "Products" ":" <p: Set_of_entities> ","
    "]" => RSlabel::create(e, c, r, r_a, i, i_p, p)
}

AssertRange: assert::Range = {
    "{" <e: AssertExpression> "}" => assert::Range::IterateOverSet(Box::new(e)),
    "{" <e1: AssertExpression> ".." <e2: AssertExpression> "}" =>
	assert::Range::IterateInRange(Box::new(e1), Box::new(e2)),
}


// -----------------------------------------------------------------------------
//                                 BHMLParser
// -----------------------------------------------------------------------------
// pub BHML: Box<RSBHML> = {
//     <g: Formula_BHML> => Box::new(g)
// };

// Formula_BHML: RSBHML = {
//     "true" => RSBHML::True,
//     "false" => RSBHML::False,
//     "(" <g: Separated<Formula_BHML, "\\/">> ")" => RSBHML::Or(g),
//     "(" <g: Separated<Formula_BHML, "/\\">> ")" => RSBHML::And(g),
//     "<" <f: Formula_Assert> ">" <g: Formula_BHML> =>
//	RSBHML::Diamond(Box::new(f), Box::new(g)),
//     "[" <f: Formula_Assert> "]" <g: Formula_BHML> =>
//	RSBHML::Box(Box::new(f), Box::new(g)),
// };


// ----------------------------------------------------------------------------
//                                File Parsing
// ----------------------------------------------------------------------------

// system
// a system is an environment, a set of entities as initial state, a context and
// a set of reaction rules.

pub System: RSsystem = {
    "Environment" ":" <delta: Environment>
    "Initial Entities" ":" <available_entities: Set>
    "Context" ":" <context_process: Context>
    "Reactions" ":" <reaction_rules: Reactions>
	=> RSsystem::from(delta.into(),
			  available_entities,
			  context_process,
			  Rc::new(reaction_rules))
}

// experiment
// an experiment is composed by a sequence of weights and a sequence of sets of
// entities of equal length.

pub Experiment: (Vec<u32>, Vec<RSset>) = {
    "Weights" ":" <w: Separated_Or<Num, ",">>
    "Sets" ":" <s: Separated_Or<Set_of_entities, ",">>
	=> (w.into_iter().map(|x| x as u32).collect::<Vec<_>>(), s),
}


// ~~~~~~~~~~~~~~~~~~~
// Instruction Parsing
// ~~~~~~~~~~~~~~~~~~~

/// Decides whetherer to print to stdout or to save to file
Helper_SO: presets::SaveOptions = {
    "Print" =>
	presets::SaveOptions {print: true, save: None},
    "Save" "(" <p: Path> ")" =>
	presets::SaveOptions {print: false, save: Some(vec![p])}
}

/// we could need to save to multiple files
SaveOptions: presets::SaveOptions = {
    <p: Separated_Or<Helper_SO, ";">> => {
	p.into_iter()
	 .reduce(|mut acc, mut e| {acc.combine(&mut e); acc})
	 .unwrap_or_default()
    }
}

/// Match for strings between nodes formatters
LiteralSeparatorNode: graph::NodeDisplayBase = {
    PATH =>
	graph::NodeDisplayBase::String {
	    string: <>.trim_end_matches("\"")
		      .trim_start_matches("\"")
		      .to_string()
	}
};

/// Match for strings between edge formatters
LiteralSeparatorEdge: graph::EdgeDisplayBase = {
    PATH =>
	graph::EdgeDisplayBase::String {
	    string: <>.trim_end_matches("\"")
		      .trim_start_matches("\"")
		      .to_string()
	}
};

NodeDisplayBase: graph::NodeDisplayBase = {
    "Hide" =>
	graph::NodeDisplayBase::Hide,
    "Entities" =>
	graph::NodeDisplayBase::Entities,
    "MaskEntities" <mask: Set> =>
	graph::NodeDisplayBase::MaskEntities{mask},
    "ExcludeEntities" <mask: Set> =>
      graph::NodeDisplayBase::ExcludeEntities{mask},
    "Context" =>
	graph::NodeDisplayBase::Context,
    "UncommonEntities" =>
	graph::NodeDisplayBase::UncommonEntities,
    "MaskUncommonentities" <mask: Set> =>
	graph::NodeDisplayBase::MaskUncommonEntities{mask},
}

/// Node display formatters separated by arbitrary strings in quotes
SeparatorNode: graph::NodeDisplay = {
    <v: NodeDisplayBase> => graph::NodeDisplay {base: vec![v]},
    <v:(<NodeDisplayBase> <LiteralSeparatorNode>)+> <e: NodeDisplayBase?> =>
	match e {
	    None => graph::NodeDisplay {
			base:
			v.iter().fold(vec![],
			    |mut acc, (a, b)| {
				acc.push(a.clone());
				acc.push(b.clone());
				acc.clone()
			    })
			},
	    Some(e) => {
		let mut v = v.iter().fold(vec![],
					  |mut acc, (a, b)| {
					      acc.push(a.clone());
					      acc.push(b.clone());
					      acc.clone()
					  });
		v.push(e);
		graph::NodeDisplay { base: v }
	    }
	}
}

EdgeDisplay: graph::EdgeDisplayBase = {
    "Hide" =>
	graph::EdgeDisplayBase::Hide,

    "Products" =>
	graph::EdgeDisplayBase::Products
	{ mask: None, filter_common: false },
    "MaskProducts" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: false },
    "UncommonProducts" =>
	graph::EdgeDisplayBase::Products
	{ mask: None, filter_common: true },
    "UncommonMaskProducts" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: true },

    "Entities" =>
	graph::EdgeDisplayBase::Entities
	{ mask: None, filter_common: false },
    "MaskEntities" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: false },
    "UncommonEntities" =>
	graph::EdgeDisplayBase::Entities
	{ mask: None, filter_common: true },
    "UncommonMaskEntities" <mask: Set> =>
	graph::EdgeDisplayBase::Entities
	{ mask: Some(mask), filter_common: true },

    "Context" =>
	graph::EdgeDisplayBase::Context
	{ mask: None, filter_common: false },
    "MaskContext" <mask: Set> =>
	graph::EdgeDisplayBase::Context
	{ mask: Some(mask), filter_common: false },
    "UncommonContext" =>
	graph::EdgeDisplayBase::Context
	{ mask: None, filter_common: true },
    "UncommonMaskContext" <mask: Set> =>
	graph::EdgeDisplayBase::Context
	{ mask: Some(mask), filter_common: true },

    "Union" =>
	graph::EdgeDisplayBase::Union
	{ mask: None, filter_common: false },
    "MaskUnion" <mask: Set> =>
	graph::EdgeDisplayBase::Union
	{ mask: Some(mask), filter_common: false },
    "UncommonUnion" =>
	graph::EdgeDisplayBase::Union
	{ mask: None, filter_common: true },
    "UncommonMaskUnion" <mask: Set> =>
	graph::EdgeDisplayBase::Union
	{ mask: Some(mask), filter_common: true },

    "Difference" =>
	graph::EdgeDisplayBase::Difference
	{ mask: None, filter_common: false },
    "MaskDifference" <mask: Set> =>
	graph::EdgeDisplayBase::Difference
	{ mask: Some(mask), filter_common: false },
    "UncommonDifference" =>
	graph::EdgeDisplayBase::Difference
	{ mask: None, filter_common: true },
    "UncommonMaskDifference" <mask: Set> =>
	graph::EdgeDisplayBase::Difference
	{ mask: Some(mask), filter_common: true },

    "EntitiesDeleted" =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: None, filter_common: false },
    "MaskEntitiesDeleted" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: Some(mask), filter_common: false },
    "UncommonEntitiesDeleted" =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: None, filter_common: true },
    "UncommonMaskEntitiesDeleted" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesDeleted
	{ mask: Some(mask), filter_common: true },

    "EntitiesAdded" =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: None, filter_common: false },
    "MaskEntitiesAdded" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: Some(mask), filter_common: false },
    "UncommonEntitiesAdded" =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: None, filter_common: true },
    "UncommonMaskEntitiesAdded" <mask: Set> =>
	graph::EdgeDisplayBase::EntitiesAdded
	{ mask: Some(mask), filter_common: true },
}

/// Edge display formatters separated by arbitrary strings in quotes
SeparatorEdge: graph::EdgeDisplay = {
    <v: EdgeDisplay> => graph::EdgeDisplay{ base: vec![v] },
    <v:(<EdgeDisplay> <LiteralSeparatorEdge>)+> <e: EdgeDisplay?> =>
	match e {
	    None => graph::EdgeDisplay{ base: v.iter().fold(vec![],
					      |mut acc, (a, b)| {
						  acc.push(a.clone());
						  acc.push(b.clone());
						  acc.clone()
					      }) },
	    Some(e) => {
		let mut v = v.iter().fold(vec![],
					  |mut acc, (a, b)| {
					      acc.push(a.clone());
					      acc.push(b.clone());
					      acc.clone()
					  });
		v.push(e);
		graph::EdgeDisplay{ base: v }
	    }
	}
}

Operation: graph::OperationType = {
    "==" => graph::OperationType::Equals,
    "="  => graph::OperationType::Equals,
    "<"  => graph::OperationType::Subset,
    "⊂"  => graph::OperationType::Subset,
    "<=" => graph::OperationType::SubsetEqual,
    "⊆"  => graph::OperationType::SubsetEqual,
    ">"  => graph::OperationType::Superset,
    "⊃"  => graph::OperationType::Superset,
    ">=" => graph::OperationType::SupersetEqual,
    "⊇"  => graph::OperationType::SupersetEqual
}

NodeColorConditional: (graph::NodeColorConditional, String) = {
    "Entities" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::NodeColorConditional::EntitiesConditional(op, set),
	    color.to_string()),
    "Context.Nill" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::Nill),
	    color.to_string()),
    "Context.RecursiveIdentifier" "(" <x: Literal> ")" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::RecursiveIdentifier(
		translator.encode(x)
	    )),
	    color.to_string()),
    "Context.EntitySet" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::EntitySet(op, set)),
	    color.to_string()),
    "Context.NonDeterministicChoice" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::NonDeterministicChoice),
	    color.to_string()),
    "Context.Summation" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::Summation),
	    color.to_string()),
    "Context.WaitEntity" "?" <color: PATH> =>
	(graph::NodeColorConditional::ContextConditional(
	    graph::ContextColorConditional::WaitEntity),
	    color.to_string()),
}


/// Node color formatter
ColorNode: graph::NodeColor = {
    <conditionals: Separated_Or<NodeColorConditional, "||">>
    "!" <base_color: PATH> =>
	graph::NodeColor { conditionals,
			   base_color: base_color.to_string() },

    "!" <base_color: PATH> =>
	graph::NodeColor { conditionals: vec![],
			   base_color: base_color.to_string() },
}

EdgeColorConditional: (graph::EdgeColorConditional, String) = {
    "Entities" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Entities(op, set),
	    color.to_string()),
    "Context" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Context(op, set),
	    color.to_string()),
    "T" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::T(op, set),
	    color.to_string()),
    "Reactants" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Reactants(op, set),
	    color.to_string()),
    "AbsentReactants" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::ReactantsAbsent(op, set),
	    color.to_string()),
    "Inhibitors" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Inhibitors(op, set),
	    color.to_string()),
    "PresentInhibitors" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::InhibitorsPresent(op, set),
	    color.to_string()),
    "Products" <op: Operation> <set: Set> "?" <color: PATH> =>
	(graph::EdgeColorConditional::Products(op, set),
	    color.to_string()),
}

ColorEdge: graph::EdgeColor = {
    <conditionals: Separated_Or<EdgeColorConditional, "||">>
    "!" <base_color: PATH> =>
	graph::EdgeColor { conditionals,
			   base_color: base_color.to_string() },

    "!" <base_color: PATH> =>
	graph::EdgeColor { conditionals: vec![],
			   base_color: base_color.to_string() },
}


GraphSaveOptions: presets::GraphSaveOptions = {
    "Dot" "|"? <s_node: SeparatorNode> "|" <s_edge: SeparatorEdge> "|"
	  <c_node: ColorNode> "|" <c_edge: ColorEdge> ">"
	<so: SaveOptions> =>
	presets::GraphSaveOptions::Dot { node_display: s_node,
					 edge_display: s_edge,
					 node_color:   c_node,
					 edge_color:   c_edge,
					 so },
    "GraphML" "|"? <s_node: SeparatorNode> "|" <s_edge: SeparatorEdge> ">"
	<so: SaveOptions> =>
	presets::GraphSaveOptions::GraphML { node_display: s_node,
					     edge_display: s_edge,
					     so },
    "Serialize" "(" <path: Path> ")" =>
	presets::GraphSaveOptions::Serialize { path },
}


Instruction: presets::Instruction = {
    "Stats" ">" <so: SaveOptions> =>
	presets::Instruction::Stats { so },
    "Target" ">" <so: SaveOptions> =>
	presets::Instruction::Target { so },
    "Run" ">" <so: SaveOptions> =>
	presets::Instruction::Run { so },
    "Loop" "(" <symbol: Literal> ")" ">" <so: SaveOptions> =>
	presets::Instruction::Loop { symbol,  so },
    "Frequency" ">" <so: SaveOptions> =>
	presets::Instruction::Frequency { so },
    "LimitFrequency" "(" <p: Path> ")" ">" <so: SaveOptions> =>
	presets::Instruction::LimitFrequency { experiment: p, so },
    "FastFrequency" "(" <p: Path> ")" ">" <so: SaveOptions> =>
	presets::Instruction::FastFrequency { experiment: p, so },
    "Digraph" ">" <gso: Separated_Or<GraphSaveOptions, "|">> =>
	presets::Instruction::Digraph { gso },
    "Bisimilarity" "(" <p: Path> ")" ">" <so: SaveOptions> =>
	presets::Instruction::Bisimilarity { system_b: p, so },
}

pub Run: presets::Instructions = {
    <sys: System> <instr: Separated_Or<Instruction, ",">> =>
	Instructions { system: presets::System::RSsystem { sys },
		       instructions: instr },

    <sys: System> =>
	Instructions { system: presets::System::RSsystem { sys },
		       instructions: vec![] },

    "Deserialize" "(" <path: Path> ")"
    <instr: Separated_Or<Instruction, ",">> =>
	Instructions { system: presets::System::Deserialize { path },
		       instructions: instr },
}
