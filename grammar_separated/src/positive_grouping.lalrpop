use std::str::FromStr;
use lalrpop_util::ParseError;

use assert::positive_grouping;
use rsprocess::{set, label};
use rsprocess::translator::Translator;
use crate::custom_error;

grammar(translator: &mut Translator);

extern {
    type Error = custom_error::UserError;
}


// -----------------------------------------------------------------------------
//                                  Helpers
// -----------------------------------------------------------------------------

// order
match {
    "!", "!=", "%", "&&", "'", "(", ")", "*", "+", ",", "-", "..", "/", ":",
    "::", ";", "<", "<=", "=", "==", ">", ">=", "AllInhibitors", "AllReactants",
    "AvailableEntities", "Context", "Entities", "Inhibitors",
    "InhibitorsPresent", "Products", "Reactants", "ReactantsAbsent",
    "SystemContext", "SystemEntities", "[", "\"", "]", "^", "^^", "edge",
    "else", "empty", "false", "for", "if", "in", "label", "length", "let",
    "neighbours", "not", "rand", "return", "source", "system", "target", "then",
    "toel", "tostr", "true", "{", "||", "}", "node",
} else {
    r"[0-9]+" => NUMBER
} else {
    r"([[:alpha:]])([[:word:]])*" => WORD
    // r"(\p{L}|\p{Emoji})(\p{L}|\p{Emoji}|\p{Dash}|\p{N})*" => WORD,
} else {
    r#""[^"]+""# => PATH, // " <- ignore comment, its for the linter in emacs
} else {
    _
}

// matches words (letter followed by numbers, letters or _)
Literal: String = {
    WORD => <>.into(),
};

Num: i64 = {
    <sign: "-"?> <start: @L> <n: NUMBER> <end: @R> =>? {
        if sign.is_some() {
            i64::from_str(n)
                  .map(|n| -n)
                  .map_err(|_| ParseError::User {
                      error: custom_error::UserError {
                          token: (start, n.into(), end),
                          error: custom_error::UserErrorTypes::NumberTooBigi64
                      }
                  })
        } else {
            i64::from_str(n)
                  .map_err(|_| ParseError::User {
                      error: custom_error::UserError {
                          token: (start, n.into(), end),
                          error: custom_error::UserErrorTypes::NumberTooBigi64
                      }
                  })
        }

    }
};

// macro for matching sequence of patterns with C as separator
Separated<T, C>: Vec<T> = {
    <mut v:(<T> C)+> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Separated_Or<T, C>: Vec<T> = {
    <v: T> => vec![v],
    <v: Separated<T, C>> => v
}

Separated_Empty<LP, T, C, RP>: Vec<T> = {
    LP RP => vec![],
    LP <v: T> RP => vec![v],
    LP <v: Separated<T, C>> RP => v
}

// -----------------------------------------------------------------------------
//                                 SetParser
// -----------------------------------------------------------------------------

PositiveSet: set::PositiveSet = {
    <s: Separated_Empty<"{", PositiveLiteral, ",", "}">> =>
        set::PositiveSet::from(s)
};

PositiveLiteral: (rsprocess::element::IdType, rsprocess::element::IdState) = {
    "+" <t: Literal> => (translator.encode(t), rsprocess::element::IdState::Positive),
    "-" <t: Literal> => (translator.encode(t), rsprocess::element::IdState::Negative),
}

// -----------------------------------------------------------------------------
//                                LabelParser
// -----------------------------------------------------------------------------

Label: label::PositiveLabel = {
    "["
       "Entities" ":" <e: PositiveSet> ","
       "Context" ":" <c: PositiveSet> ","
       "Reactants" ":" <r: PositiveSet> ","
       "ReactantsAbsent" ":" <r_a: PositiveSet> ","
       "Inhibitors" ":" <i: PositiveSet> ","
       "InhibitorsPresent" ":" <i_p: PositiveSet> ","
       "Products" ":" <p: PositiveSet> ","?
    "]" => label::PositiveLabel::create(e, c, r, r_a, i, i_p, p)
}


// -----------------------------------------------------------------------------
//                               GroupingParser
// -----------------------------------------------------------------------------
pub Group: Box<positive_grouping::PositiveAssert> = {
     "node" "{" <f: GroupTree> "}" =>
        Box::new(positive_grouping::PositiveAssert{tree: f}),
};

GroupTree: positive_grouping::PositiveTree = {
    <t1: GroupTree2> <t2: GroupTree> =>
        positive_grouping::PositiveTree::Concat(Box::new(t1), Box::new(t2)),
    <t: GroupTree2> => t,
}

GroupTree2: positive_grouping::PositiveTree = {
    #[precedence(level="1")]
    "if" <e: GroupExpression>
    "then" "{" <t: GroupTree> "}" ";"? =>
        positive_grouping::PositiveTree::If(Box::new(e), Box::new(t)),

    #[precedence(level="0")]
    "if" <e: GroupExpression>
    "then" "{" <t1: GroupTree> "}"
    "else" "{" <t2: GroupTree> "}" ";"? =>
        positive_grouping::PositiveTree::IfElse(Box::new(e), Box::new(t1), Box::new(t2)),

    "let" <v: GroupVariable> <q: GroupQualifier?> "=" <e: GroupExpression> ";"
        => positive_grouping::PositiveTree::Assignment(v, q, Box::new(e)),

    "return" <e: GroupExpression> ";" =>
        positive_grouping::PositiveTree::Return(Box::new(e)),

    "for" <v: GroupVariable> "in" <r: GroupRange> "{" <t: GroupTree> "}" ";"? =>
        positive_grouping::PositiveTree::For(v, r, Box::new(t)),
}

GroupVariable: positive_grouping::PositiveVariable = {
    #[precedence(level="0")]
    "entities" => positive_grouping::PositiveVariable::Special(positive_grouping::Special::Entities),
    "node"  => positive_grouping::PositiveVariable::Special(positive_grouping::Special::Node),
    #[precedence(level="1")]
    <v: Literal> => positive_grouping::PositiveVariable::Id(v),
}

GroupExpression: positive_grouping::PositiveExpression = {
    #[precedence(level="100")]
    <unp: GroupUnaryPrefix> "(" <e: GroupExpression> ")" =>
        positive_grouping::PositiveExpression::Unary(unp, Box::new(e)),

    #[precedence(level="50")]
    <e: GroupExpression> "." <uns: GroupUnarySuffix> =>
        positive_grouping::PositiveExpression::Unary(uns, Box::new(e)),

    #[precedence(level="100")] #[assoc(side="left")]
    <e1: GroupExpression> <b: GroupBinary> <e2: GroupExpression> =>
        positive_grouping::PositiveExpression::Binary(b, Box::new(e1), Box::new(e2)),

    #[precedence(level="100")]
    <b: GroupBinaryPrefix>
    "(" <e1: GroupExpression> "," <e2: GroupExpression> ")" =>
        positive_grouping::PositiveExpression::Binary(b, Box::new(e1), Box::new(e2)),

    #[precedence(level="0")]
    <t: GroupTerm> => t,
}

GroupTerm: positive_grouping::PositiveExpression = {
    "true" => positive_grouping::PositiveExpression::True,
    "false" => positive_grouping::PositiveExpression::False,

    <v: GroupVariable> => positive_grouping::PositiveExpression::Var(v),

    // If changing IntegerType in assert.rs, also change from Num to another
    // similar parser with different return type
    <i: Num> => positive_grouping::PositiveExpression::Integer(i),

    <lab: Label> => positive_grouping::PositiveExpression::Label(Box::new(lab)),
    <set: PositiveSet> => positive_grouping::PositiveExpression::Set(set),
    "'" <el: PositiveLiteral> "'" =>
        positive_grouping::PositiveExpression::PositiveElement(el.into()),

    // strings
    PATH => positive_grouping::PositiveExpression::String(<>.trim_end_matches("\"")
                                         .trim_start_matches("\"")
                                         .to_string()),
    // allow arbitrary parenthesis
    "(" <e: GroupExpression> ")" => e,
}

GroupRange: positive_grouping::PositiveRange = {
    "{" <e: GroupExpression> "}" =>
        positive_grouping::PositiveRange::IterateOverSet(Box::new(e)),
    "{" <e1: GroupExpression> ".." <e2: GroupExpression> "}" =>
        positive_grouping::PositiveRange::IterateInRange(Box::new(e1), Box::new(e2)),
}

GroupUnaryPrefix: positive_grouping::PositiveUnary = {
    "not" => positive_grouping::PositiveUnary::Not,
    "rand" => positive_grouping::PositiveUnary::Rand,
}

GroupUnarySuffix: positive_grouping::PositiveUnary = {
    #[precedence(level="0")]
    "empty" => positive_grouping::PositiveUnary::Empty,
    "length" => positive_grouping::PositiveUnary::Length,
    "tostr" => positive_grouping::PositiveUnary::ToStr,
    "toel" => positive_grouping::PositiveUnary::ToEl,

    #[precedence(level="1")]
    <q: GroupQualifier> => positive_grouping::PositiveUnary::Qualifier(q),
}

GroupQualifierRestricted: positive_grouping::QualifierRestricted = {
    "Entities" => positive_grouping::QualifierRestricted::Entities,
    "Context" => positive_grouping::QualifierRestricted::Context,
    "Reactants" => positive_grouping::QualifierRestricted::Reactants,
    "ReactantsAbsent" => positive_grouping::QualifierRestricted::ReactantsAbsent,
    "Inhibitors" => positive_grouping::QualifierRestricted::Inhibitors,
    "InhibitorsPresent" => positive_grouping::QualifierRestricted::InhibitorsPresent,
    "Products" => positive_grouping::QualifierRestricted::Products,
}

GroupQualifierLabel: positive_grouping::QualifierLabel = {
    "AvailableEntities" => positive_grouping::QualifierLabel::AvailableEntities,
    "AllReactants" => positive_grouping::QualifierLabel::AllReactants,
    "AllInhibitors" => positive_grouping::QualifierLabel::AllInhibitors,
}

GroupQualifierSystem: positive_grouping::QualifierSystem = {
    "SystemEntities" => positive_grouping::QualifierSystem::Entities,
    "SystemContext" => positive_grouping::QualifierSystem::Context,
}

GroupQualifierEdge: positive_grouping::QualifierEdge = {
    "source" => positive_grouping::QualifierEdge::Source,
    "target" => positive_grouping::QualifierEdge::Target,
}

GroupQualifierNode: positive_grouping::QualifierNode = {
    "neighbours" => positive_grouping::QualifierNode::Neighbours,
    "system" => positive_grouping::QualifierNode::System,
}

GroupQualifier: positive_grouping::PositiveQualifier = {
    <q: GroupQualifierSystem> => positive_grouping::PositiveQualifier::System(q),
    <q: GroupQualifierLabel> => positive_grouping::PositiveQualifier::Label(q),
    <q: GroupQualifierRestricted> => positive_grouping::PositiveQualifier::Restricted(q),
    <q: GroupQualifierEdge> => positive_grouping::PositiveQualifier::Edge(q),
    <q: GroupQualifierNode> => positive_grouping::PositiveQualifier::Node(q),
}

GroupBinary: positive_grouping::PositiveBinary = {
    "&&" => positive_grouping::PositiveBinary::And,
    "||" => positive_grouping::PositiveBinary::Or,
    "^^" => positive_grouping::PositiveBinary::Xor,
    "<" => positive_grouping::PositiveBinary::Less,
    "<=" => positive_grouping::PositiveBinary::LessEq,
    ">" => positive_grouping::PositiveBinary::More,
    ">=" => positive_grouping::PositiveBinary::MoreEq,
    "==" => positive_grouping::PositiveBinary::Eq,
    "!=" => positive_grouping::PositiveBinary::NotEq,
    "+" => positive_grouping::PositiveBinary::Plus,
    "-" => positive_grouping::PositiveBinary::Minus,
    "*" => positive_grouping::PositiveBinary::Times,
    "^" => positive_grouping::PositiveBinary::Exponential,
    "/" => positive_grouping::PositiveBinary::Quotient,
    "%" => positive_grouping::PositiveBinary::Reminder,
    "::" => positive_grouping::PositiveBinary::Concat,
}

GroupBinaryPrefix: positive_grouping::PositiveBinary = {
    "substr" => positive_grouping::PositiveBinary::SubStr,
    "min" => positive_grouping::PositiveBinary::Min,
    "max" => positive_grouping::PositiveBinary::Max,
    "commonsubstr" => positive_grouping::PositiveBinary::CommonSubStr,
}
